name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      confirm_deployment:
        description: 'Type "DEPLOY" to confirm production deployment'
        required: true
        default: ''

env:
  AWS_REGION: eu-west-1
  TERRAFORM_VERSION: 1.6.0

jobs:
  terraform-plan:
    name: Terraform Plan (Production)
    runs-on: ubuntu-latest
    environment: production
    if: github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/main'
    
    steps:
    - name: Check manual confirmation
      if: github.event_name == 'workflow_dispatch'
      run: |
        if [ "${{ github.event.inputs.confirm_deployment }}" != "DEPLOY" ]; then
          echo "‚ùå Deployment cancelled. Please type 'DEPLOY' to confirm."
          exit 1
        fi
        echo "‚úÖ Deployment confirmed"

    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install Python dependencies
      run: |
        cd backend
        pip install -r requirements.txt -t .

    - name: Package Lambda functions
      run: |
        cd backend
        # Create zip files with consistent timestamps to avoid hash changes
        zip -r ../terraform/submit_cv.zip submit_cv.py
        zip -r ../terraform/list_applications.zip list_applications.py
        zip -r ../terraform/get_application.zip get_application.py
        zip -r ../terraform/admin_login.zip admin_login.py
        
        # Set consistent timestamp to avoid hash changes between jobs
        touch -t 202401010000 ../terraform/*.zip

    - name: Upload Lambda Packages
      uses: actions/upload-artifact@v4
      with:
        name: lambda-packages
        path: terraform/*.zip
        retention-days: 1

    - name: Run Security Scan
      run: |
        echo "üîç Running basic security checks..."
        pip install checkov
        checkov -d terraform/ --framework terraform --compact --quiet || echo "Security scan completed with warnings"
        
        # Check for secrets
        echo "Checking for hardcoded secrets..."
        if grep -r "AKIA\|aws_secret_access_key\|password.*=" terraform/ --exclude-dir=.terraform || true; then
          echo "‚ö†Ô∏è Potential secrets found - please review"
        else
          echo "‚úÖ No obvious secrets detected"
        fi
      continue-on-error: true

    - name: Terraform Format
      id: fmt
      run: terraform fmt -check
      working-directory: ./terraform
      continue-on-error: true

    - name: Terraform Init
      id: init
      run: |
        terraform init \
          -backend-config="bucket=terraform-state-devops-job-portal" \
          -backend-config="key=prod/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=terraform-locks"
      working-directory: ./terraform

    - name: Terraform Workspace
      id: workspace
      run: |
        terraform workspace select prod || terraform workspace new prod
      working-directory: ./terraform

    - name: Terraform Validate
      id: validate
      run: terraform validate -no-color
      working-directory: ./terraform

    - name: Terraform Plan
      id: plan
      run: |
        terraform plan -no-color -var="environment=prod" -var="db_password=${{ secrets.PROD_DB_PASSWORD }}" -out=tfplan
      working-directory: ./terraform

    - name: Upload Plan
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan-prod
        path: terraform/tfplan
        retention-days: 5

  deploy:
    name: Deploy to Production
    needs: terraform-plan
    runs-on: ubuntu-latest
    environment: production
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install Python dependencies
      run: |
        cd backend
        pip install -r requirements.txt -t .

    - name: Download Lambda Packages
      uses: actions/download-artifact@v4
      with:
        name: lambda-packages
        path: terraform/

    - name: Terraform Init
      run: |
        terraform init \
          -backend-config="bucket=terraform-state-devops-job-portal" \
          -backend-config="key=prod/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=terraform-locks"
      working-directory: ./terraform

    - name: Terraform Workspace
      run: |
        terraform workspace select prod
      working-directory: ./terraform

    - name: Download Plan
      uses: actions/download-artifact@v4
      with:
        name: terraform-plan-prod
        path: terraform/

    - name: Import Existing DB Subnet Group
      run: |
        echo "üîç Checking if DB subnet group needs to be imported..."
        
        # Define the expected DB subnet group name
        DB_SUBNET_GROUP_NAME="devops-job-portal-prod-db-subnet-group"
        
        # Check if resource exists in Terraform state
        if terraform state show aws_db_subnet_group.main >/dev/null 2>&1; then
          echo "‚úÖ DB subnet group already in terraform state"
          terraform state show aws_db_subnet_group.main | head -10
        else
          echo "‚ùå DB subnet group NOT in terraform state, checking AWS..."
          
          # Verify the resource exists in AWS first
          if aws rds describe-db-subnet-groups --db-subnet-group-name "$DB_SUBNET_GROUP_NAME" >/dev/null 2>&1; then
            echo "‚úÖ DB subnet group '$DB_SUBNET_GROUP_NAME' exists in AWS"
            
            # Show all current state resources for debugging
            echo "üìã Current Terraform state resources:"
            terraform state list
            
            # Try import with retries
            echo "üîÑ Attempting to import DB subnet group..."
            
            if terraform import -var="environment=prod" -var="db_password=${{ secrets.PROD_DB_PASSWORD }}" aws_db_subnet_group.main "$DB_SUBNET_GROUP_NAME"; then
              echo "‚úÖ Import successful with variables"
            elif terraform import aws_db_subnet_group.main "$DB_SUBNET_GROUP_NAME"; then  
              echo "‚úÖ Import successful without variables"
            else
              echo "‚ùå All import attempts failed"
              echo "This deployment will likely fail due to resource conflict"
              exit 1
            fi
            
            # Final verification with detailed output
            if terraform state show aws_db_subnet_group.main >/dev/null 2>&1; then
              echo "‚úÖ Import verification: resource successfully imported"
              echo "üìã Imported resource details:"
              terraform state show aws_db_subnet_group.main | head -5
            else
              echo "‚ùå Import verification failed: resource still not in state"
              exit 1
            fi
            
          else
            echo "‚ùå DB subnet group '$DB_SUBNET_GROUP_NAME' does not exist in AWS"
            echo "Terraform will create it during apply"
          fi
        fi
      working-directory: ./terraform
      continue-on-error: false

    - name: Terraform Apply
      run: |
        echo "üöÄ Applying Terraform changes to production..."
        terraform apply -auto-approve tfplan
        echo "‚úÖ Terraform deployment completed"
      working-directory: ./terraform

    - name: Get Terraform Outputs
      id: terraform-output
      run: |
        echo "frontend_bucket=$(terraform output -raw frontend_bucket_name)" >> $GITHUB_OUTPUT
        echo "api_gateway_url=$(terraform output -raw api_gateway_url)" >> $GITHUB_OUTPUT
        echo "frontend_url=$(terraform output -raw frontend_website_url)" >> $GITHUB_OUTPUT
      working-directory: ./terraform

    - name: Update Frontend Configuration
      run: |
        sed -i "s|https://your-api-gateway-url.execute-api.us-east-1.amazonaws.com/dev|${{ steps.terraform-output.outputs.api_gateway_url }}|g" frontend/js/app.js

    - name: Deploy Frontend to S3
      run: |
        aws s3 sync frontend/ s3://${{ steps.terraform-output.outputs.frontend_bucket }} --delete
        aws s3 cp frontend/index.html s3://${{ steps.terraform-output.outputs.frontend_bucket }}/index.html --cache-control "no-cache"

    - name: Production Health Check
      run: |
        echo "üè• Running production health checks..."
        
        # Test API Gateway
        if curl -f "${{ steps.terraform-output.outputs.api_gateway_url }}/applications" >/dev/null 2>&1; then
          echo "‚úÖ API Gateway is responding"
        else
          echo "‚ö†Ô∏è API Gateway health check failed"
        fi
        
        # Test frontend
        if curl -f "http://${{ steps.terraform-output.outputs.frontend_url }}" >/dev/null 2>&1; then
          echo "‚úÖ Frontend is accessible"
        else
          echo "‚ö†Ô∏è Frontend health check failed"
        fi
        
        echo "‚úÖ Health checks completed"
      continue-on-error: true

    - name: Notify deployment success
      if: success()
      run: |
        echo "üéâ Production deployment successful!"
        echo "Frontend URL: http://${{ steps.terraform-output.outputs.frontend_url }}"
        echo "API URL: ${{ steps.terraform-output.outputs.api_gateway_url }}"
        echo "Deployed by: @${{ github.actor }}"
        echo "Commit: ${{ github.sha }}"
