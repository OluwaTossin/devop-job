name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      confirm_deployment:
        description: 'Type "DEPLOY" to confirm production deployment'
        required: true
        default: ''

env:
  AWS_REGION: eu-west-1
  TERRAFORM_VERSION: 1.6.0

jobs:
  validate-input:
    name: Validate Deployment Input
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
    - name: Check confirmation
      run: |
        if [ "${{ github.event.inputs.confirm_deployment }}" != "DEPLOY" ]; then
          echo "âŒ Deployment cancelled. Please type 'DEPLOY' to confirm."
          exit 1
        fi
        echo "âœ… Deployment confirmed"

  terraform-plan:
    name: Terraform Plan (Production)
    runs-on: ubuntu-latest
    environment: production
    needs: [validate-input]
    if: always() && (needs.validate-input.result == 'success' || github.event_name == 'push')
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Terraform Format
      id: fmt
      run: terraform fmt -check
      working-directory: ./terraform

    - name: Terraform Init
      id: init
      run: |
        terraform init \
          -backend-config="bucket=terraform-state-devops-job-portal" \
          -backend-config="key=prod/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=terraform-locks"
      working-directory: ./terraform

    - name: Terraform Workspace
      id: workspace
      run: |
        terraform workspace select prod || terraform workspace new prod
      working-directory: ./terraform

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install Python dependencies
      run: |
        cd backend
        pip install -r requirements.txt -t .

    - name: Package Lambda functions
      run: |
        cd backend
        zip -r ../terraform/submit_cv.zip submit_cv.py
        zip -r ../terraform/list_applications.zip list_applications.py
        zip -r ../terraform/get_application.zip get_application.py
        zip -r ../terraform/admin_login.zip admin_login.py

    - name: Terraform Validate
      id: validate
      run: terraform validate -no-color
      working-directory: ./terraform

    - name: Terraform Plan
      id: plan
      run: |
        terraform plan -no-color -var="environment=prod" -var="db_password=${{ secrets.PROD_DB_PASSWORD }}" -out=tfplan
      working-directory: ./terraform

    - name: Upload Plan Artifact
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan
        path: terraform/tfplan

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: always() && needs.terraform-plan.result != 'cancelled'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Run Checkov (Terraform Security Scan)
      run: |
        pip install checkov
        checkov -d terraform/ --framework terraform --output cli --soft-fail
      continue-on-error: true

    - name: Run basic security checks
      run: |
        echo "ðŸ” Running security checks..."
        echo "âœ“ Checking for hardcoded secrets"
        if grep -r "AKIA\|aws_secret_access_key\|password.*=" terraform/ --exclude-dir=.terraform || true; then
          echo "âš ï¸  Potential secrets found - please review"
        else
          echo "âœ“ No obvious secrets detected"
        fi

  approval:
    name: Manual Approval
    runs-on: ubuntu-latest
    environment: production-approval
    needs: [terraform-plan, security-scan]
    if: github.event_name == 'push' && always() && needs.terraform-plan.result != 'cancelled' && needs.security-scan.result != 'cancelled'
    
    steps:
    - name: Request Approval
      run: |
        echo "ðŸš€ Production deployment requires manual approval"
        echo "Review the Terraform plan and security scan results before approving"

  deploy:
    name: Deploy to Production
    needs: [terraform-plan, security-scan, approval]
    runs-on: ubuntu-latest
    environment: production
    if: always() && (needs.approval.result == 'success' || github.event_name == 'workflow_dispatch') && needs.terraform-plan.result != 'cancelled'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install Python dependencies
      run: |
        cd backend
        pip install -r requirements.txt -t .

    - name: Package Lambda functions (Deploy)
      run: |
        cd backend
        # Remove any existing packages to ensure clean build
        rm -f ../terraform/*.zip
        # Create fresh packages with consistent timestamps
        zip -r ../terraform/submit_cv.zip submit_cv.py
        zip -r ../terraform/list_applications.zip list_applications.py  
        zip -r ../terraform/get_application.zip get_application.py
        zip -r ../terraform/admin_login.zip admin_login.py
        # Set consistent timestamps to avoid hash changes
        touch -t 202401010000 ../terraform/*.zip

    - name: Download Terraform Plan
      uses: actions/download-artifact@v4
      with:
        name: terraform-plan
        path: terraform/

    - name: Terraform Init
      run: |
        terraform init \
          -backend-config="bucket=terraform-state-devops-job-portal" \
          -backend-config="key=prod/terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=terraform-locks"
      working-directory: ./terraform

    - name: Terraform Workspace
      run: |
        terraform workspace select prod
      working-directory: ./terraform

    - name: Handle Existing Resources
      run: |
        echo "ðŸ”„ Importing existing production resources into Terraform state..."
        
        # Get current account ID for imports
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "AWS Account ID: $ACCOUNT_ID"
        
        # Set variables for consistency
        DB_PASSWORD="${{ secrets.PROD_DB_PASSWORD || 'ChangeMe123!' }}"
        
        # Import Lambda functions if they exist
        echo "Importing Lambda functions..."
        terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_lambda_function.admin_login devops-job-portal-prod-admin-login 2>/dev/null && echo "âœ… Admin login Lambda imported" || echo "âš ï¸  Admin login Lambda import skipped"
        terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_lambda_function.submit_cv devops-job-portal-prod-submit-cv 2>/dev/null && echo "âœ… Submit CV Lambda imported" || echo "âš ï¸  Submit CV Lambda import skipped"
        terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_lambda_function.list_applications devops-job-portal-prod-list-applications 2>/dev/null && echo "âœ… List applications Lambda imported" || echo "âš ï¸  List applications Lambda import skipped"
        terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_lambda_function.get_application devops-job-portal-prod-get-application 2>/dev/null && echo "âœ… Get application Lambda imported" || echo "âš ï¸  Get application Lambda import skipped"
        
        # Import Lambda permissions
        echo "Importing Lambda permissions..."
        terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_lambda_permission.admin_login devops-job-portal-prod-admin-login/AllowExecutionFromAPIGateway 2>/dev/null && echo "âœ… Admin login permission imported" || echo "âš ï¸  Admin login permission import skipped"
        terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_lambda_permission.submit_cv devops-job-portal-prod-submit-cv/AllowExecutionFromAPIGateway 2>/dev/null && echo "âœ… Submit CV permission imported" || echo "âš ï¸  Submit CV permission import skipped"
        terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_lambda_permission.list_applications devops-job-portal-prod-list-applications/AllowExecutionFromAPIGateway 2>/dev/null && echo "âœ… List applications permission imported" || echo "âš ï¸  List applications permission import skipped"
        terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_lambda_permission.get_application devops-job-portal-prod-get-application/AllowExecutionFromAPIGateway 2>/dev/null && echo "âœ… Get application permission imported" || echo "âš ï¸  Get application permission import skipped"
        
        # Import DB subnet group if it exists
        echo "Importing DB subnet group..."
        terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_db_subnet_group.main devops-job-portal-prod-db-subnet-group 2>/dev/null && echo "âœ… DB subnet group imported" || echo "âš ï¸  DB subnet group import skipped"
        
        # Import VPC and networking resources
        echo "Importing VPC resources..."
        VPC_ID=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=devops-job-portal-prod-vpc" --query "Vpcs[0].VpcId" --output text 2>/dev/null)
        if [ "$VPC_ID" != "None" ] && [ "$VPC_ID" != "" ]; then
          terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_vpc.main $VPC_ID 2>/dev/null && echo "âœ… VPC imported" || echo "âš ï¸  VPC import skipped"
        fi
        
        # Import subnets
        echo "Importing subnet resources..."
        PRIVATE_SUBNETS=($(aws ec2 describe-subnets --filters "Name=tag:Name,Values=devops-job-portal-prod-private-*" --query "Subnets[].SubnetId" --output text 2>/dev/null))
        for i in "${!PRIVATE_SUBNETS[@]}"; do
          if [ "${PRIVATE_SUBNETS[$i]}" != "None" ] && [ "${PRIVATE_SUBNETS[$i]}" != "" ]; then
            terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" "aws_subnet.private[$i]" "${PRIVATE_SUBNETS[$i]}" 2>/dev/null && echo "âœ… Private subnet $i imported" || echo "âš ï¸  Private subnet $i import skipped"
          fi
        done
        
        # Import public subnets too
        PUBLIC_SUBNETS=($(aws ec2 describe-subnets --filters "Name=tag:Name,Values=devops-job-portal-prod-public-*" --query "Subnets[].SubnetId" --output text 2>/dev/null))
        for i in "${!PUBLIC_SUBNETS[@]}"; do
          if [ "${PUBLIC_SUBNETS[$i]}" != "None" ] && [ "${PUBLIC_SUBNETS[$i]}" != "" ]; then
            terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" "aws_subnet.public[$i]" "${PUBLIC_SUBNETS[$i]}" 2>/dev/null && echo "âœ… Public subnet $i imported" || echo "âš ï¸  Public subnet $i import skipped"
          fi
        done
        
        # Import security groups
        echo "Importing security groups..."
        RDS_SG_ID=$(aws ec2 describe-security-groups --filters "Name=tag:Name,Values=devops-job-portal-prod-rds-sg" --query "SecurityGroups[0].GroupId" --output text 2>/dev/null)
        if [ "$RDS_SG_ID" != "None" ] && [ "$RDS_SG_ID" != "" ]; then
          terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_security_group.rds $RDS_SG_ID 2>/dev/null && echo "âœ… RDS security group imported" || echo "âš ï¸  RDS security group import skipped"
        fi
        
        LAMBDA_SG_ID=$(aws ec2 describe-security-groups --filters "Name=tag:Name,Values=devops-job-portal-prod-lambda-sg" --query "SecurityGroups[0].GroupId" --output text 2>/dev/null)
        if [ "$LAMBDA_SG_ID" != "None" ] && [ "$LAMBDA_SG_ID" != "" ]; then
          terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_security_group.lambda $LAMBDA_SG_ID 2>/dev/null && echo "âœ… Lambda security group imported" || echo "âš ï¸  Lambda security group import skipped"
        fi
        
        # Import RDS instance if it exists
        echo "Importing RDS instance..."
        terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_db_instance.main devops-job-portal-prod-db 2>/dev/null && echo "âœ… RDS instance imported" || echo "âš ï¸  RDS instance import skipped"
        
        # Import S3 buckets
        echo "Importing S3 buckets..."
        terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_s3_bucket.frontend devops-job-portal-prod-frontend 2>/dev/null && echo "âœ… Frontend S3 bucket imported" || echo "âš ï¸  Frontend S3 bucket import skipped"
        terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_s3_bucket.cv_storage devops-job-portal-prod-cv-storage 2>/dev/null && echo "âœ… CV storage S3 bucket imported" || echo "âš ï¸  CV storage S3 bucket import skipped"
        
        # Import API Gateway
        echo "Importing API Gateway..."
        API_ID=$(aws apigateway get-rest-apis --query "items[?name=='devops-job-portal-prod-api'].id" --output text 2>/dev/null)
        if [ "$API_ID" != "None" ] && [ "$API_ID" != "" ]; then
          terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_api_gateway_rest_api.main $API_ID 2>/dev/null && echo "âœ… API Gateway imported" || echo "âš ï¸  API Gateway import skipped"
        fi
        
        # Import IAM roles
        echo "Importing IAM roles..."
        terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_iam_role.lambda devops-job-portal-prod-lambda-role 2>/dev/null && echo "âœ… Lambda IAM role imported" || echo "âš ï¸  Lambda IAM role import skipped"
        terraform import -var="environment=prod" -var="db_password=$DB_PASSWORD" aws_iam_role.admin_login_lambda devops-job-portal-prod-admin-login-lambda 2>/dev/null && echo "âœ… Admin login IAM role imported" || echo "âš ï¸  Admin login IAM role import skipped"
        
        echo "âœ… Resource import process completed"
      working-directory: ./terraform
      continue-on-error: true

    - name: Terraform Apply
      run: |
        echo "ðŸš€ Applying Terraform changes to production..."
        
        # Set variables for consistency
        DB_PASSWORD="${{ secrets.PROD_DB_PASSWORD || 'ChangeMe123!' }}"
        
        # Force refresh state to sync with AWS
        terraform refresh -var="environment=prod" -var="db_password=$DB_PASSWORD" || echo "Refresh completed"
        
        # Apply the plan
        terraform apply -auto-approve tfplan || {
          echo "âš ï¸ Apply failed, attempting targeted fixes..."
          
          # Try to fix DB subnet group issue by recreating it
          terraform taint aws_db_subnet_group.main 2>/dev/null || echo "Taint skipped"
          
          # Generate new plan and apply
          terraform plan -var="environment=prod" -var="db_password=$DB_PASSWORD" -out=recovery.tfplan
          terraform apply -auto-approve recovery.tfplan
        }
        
        echo "âœ… Terraform apply completed"
      working-directory: ./terraform

    - name: Get Terraform Outputs
      id: terraform-output
      run: |
        FRONTEND_BUCKET=$(terraform output -raw frontend_bucket_name)
        API_URL=$(terraform output -raw api_gateway_url)
        FRONTEND_URL=$(terraform output -raw frontend_website_url)
        
        echo "frontend_bucket=$FRONTEND_BUCKET" >> $GITHUB_OUTPUT
        echo "api_gateway_url=$API_URL" >> $GITHUB_OUTPUT  
        echo "frontend_url=$FRONTEND_URL" >> $GITHUB_OUTPUT
      working-directory: ./terraform

    - name: Update Frontend Configuration
      run: |
        sed -i "s|https://your-api-gateway-url.execute-api.us-east-1.amazonaws.com/dev|${{ steps.terraform-output.outputs.api_gateway_url }}|g" frontend/js/app.js

    - name: Deploy Frontend to S3
      run: |
        aws s3 sync frontend/ s3://${{ steps.terraform-output.outputs.frontend_bucket }} --delete
        aws s3 cp frontend/index.html s3://${{ steps.terraform-output.outputs.frontend_bucket }}/index.html --cache-control "no-cache"

    - name: Run Post-Deployment Tests
      run: |
        # Test API Gateway health
        curl -f "${{ steps.terraform-output.outputs.api_gateway_url }}/applications"
        
        # Test frontend accessibility  
        curl -f "http://${{ steps.terraform-output.outputs.frontend_url }}"

    - name: Notify deployment success
      if: success()
      run: |
        echo "âœ… Production deployment successful!"
        echo "Frontend: http://${{ steps.terraform-output.outputs.frontend_url }}"
        echo "API: ${{ steps.terraform-output.outputs.api_gateway_url }}"

    - name: Create GitHub Release
      if: success() && github.event_name == 'push'
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: release-${{ github.run_number }}
        release_name: Production Release ${{ github.run_number }}
        body: |
          ðŸš€ Production deployment successful!
          
          **Deployed Changes:**
          - Commit: ${{ github.sha }}
          - Branch: ${{ github.ref }}
          - Workflow: ${{ github.workflow }}
          
          **URLs:**
          - Frontend: http://${{ steps.terraform-output.outputs.frontend_url }}
          - API: ${{ steps.terraform-output.outputs.api_gateway_url }}
          
          **Infrastructure:**
          - Environment: Production
          - Region: ${{ env.AWS_REGION }}
          - Deployed by: @${{ github.actor }}
        draft: false
        prerelease: false
      continue-on-error: true

